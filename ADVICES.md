# Стажировки для Backend-разработчиков в Авито: на что мы смотрим при проверке работ
Наши разработчики проанализировали тестовые задания кандидатов прошедшего отбора и написали статью о лучших подходах и наиболее частых ошибках в работах.  Все совпадения, конечно же, случайны :)
# Инструкция для запуска проекта
Проверяющие должны просмотреть много кода и проверить работоспособность нескольких проектов.
Помогите им быстрее перейти к интересному — к вашему коду и тестированию логики приложения. Для этого подготовьте понятную инструкцию по проекту.
Это точно будет отмечено при проверке и поможет вам выделиться среди других кандидатов.
## О чём можно написать
Как запустить проект. Например:
```markdown
Для запуска проекта нужно выполнить команду `docker-compose up`.
После этого сервис будет доступен на порту `:8080`
```
## Проверка
Перед отправкой нужно проверить, что проект без проблем запускается с 0:
- указанный в инструкции скрипт завершается без ошибок;
- миграции базы данных успешно проходят;
- сервис запускается;
- API сервиса работает.
# Проект должен запускаться
Проекты некоторых кандидатов не запускались на компьютере проверяющего.
Проверьте, что ваш сервис запускается «с нуля», а базу данных легко мигрировать.
Правилом хорошего тона считается добавить Dockerfile и параметры окружения (ENV-параметры), чтобы сервис можно было запускать на любой системе.
# Формат ответа
Часто кандидаты забывают соблюсти формат ответа, который указан [в задании](https://github.com/avito-tech/tech-internship/blob/main/Tech%20Internships/Backend/Backend-trainee-assignment-autumn-2024/openapi.yml).
В итоге возвращается ответ в формате `json`, даже когда нужен `text/plain`,  или для некоторых случаев не проставляется нужный заголовок.
Исправить это просто — внимательность и
```go
w.Header().Set("Content-Type", "application/json")
```
# Валидация входных данных
Если не проверять входные данные на корректность,   пользователь может случайно (или намеренно) повредить или получить доступ к данным других юзеров,  а в худшем случае — ко всей базе данных.
## Базовые валидации
 Добавляйте валидации в контроллерах при парсинге запросов, чтобы  по системе передавались  корректные данные.
Если валидация не прошла — сразу возвращать ошибку.
Например:
```go

type TenderServiceType string

const (
	TenderServiceTypeConstruction TenderServiceType = "Construction"
	TenderServiceTypeDelivery     TenderServiceType = "Delivery"
	TenderServiceTypeManufacture  TenderServiceType = "Manufacture"
)

func (tst TenderServiceType) Validate() bool {
	switch tst {
	case TenderServiceTypeConstruction, TenderServiceTypeDelivery, TenderServiceTypeManufacture:
		return true
	default:
		return false
	}
}

// ...

types := r.URL.Query()["service_type"]

serviceTypes := make([]TenderServiceType{}, 0, len(types))
for _, t := range types {
	tst := TenderServiceType(t)
	if !tst.Validate() {
		continue
	}
	serviceTypes = append(serviceTypes, tst)
}

if len(serviceTypes) == 0 {
	// возвращаем ошибку
}
```

## Специфические валидации
Важно не забывать про отношения между сущностями.
Допустим, пользователь Вася авторизован, но у него нет прав на изменение предложения, которое создал пользователь Петя.
**Для таких проверок можно или делать дополнительный запрос в базу данных**:
```go
func (s *Storage) checkRelationToOrganization(ctx context.Context, userId, orgId uuid.UUID) bool {
	res := 0
	query := `SELECT 1 FROM organization_responsible WHERE user_id = $1 AND organization_id = $2;`
	_ = s.conn.QueryRow(ctx, query, userId, orgId).Scan(&res) // ошибку нужно обязательно обработать
	return res > 0
}
```

или при обычном запросе добавить дополнительное условие.
** о построении запросов к базе данных есть отдельный раздел.
Особенно важно проверять авторизацию пользователя.  Подробнее можно почитать в [разборе заданий предыдущей волны](https://github.com/avito-tech/tech-internship/blob/main/Tech%20Internships/Backend/Backend-trainee-assignment-spring-2024/Solution%20and%20advice/%D0%90%D0%B2%D1%82%D0%BE%D1%80%D0%B8%D0%B7%D0%B0%D1%86%D0%B8%D1%8F.md)
# Code Style
Следование общепринятым рекомендациям по стилю кода делает его более понятным, читаемым, поддерживаемым, упрощает внесение изменений.

Наиболее частые проблемы:
- не используется линтер, например golangci-lint, который мог бы исправить часть допущенных ошибок;
- аналогично для языка python не соблюдается PEP8, не используется линтер, например flake8;
- магические строки (не вынесены в константы);
- нет логических разделений между блоками;
- мега-структуры/интерфейсы с большой зоной ответственности;
- не оборачиваются ошибки;
- импорты не отсортированы;
- не пробрасывается контекст.
# Меньше повторяющегося кода
Проверяющий смотрит не только, насколько правильно работает код, но и как легко его поддерживать в дальнейшем.
Если в коде часто встречаются дубли (много одинаковых строк), такой код сложнее поддерживать, он больше подвержен ошибкам.
Старайтесь выносить повторяющуюся логику в отдельные функции.
Например:

```go
func respondWithError(w http.ResponseWriter, statusCode int, handlerName string, err error) {
	slog.Error(err.Error(), "handler", handlerName)

	w.Header().Set("Content-Type", "application/json")
	w.WriteHeader(statusCode)
	_, _ = w.Write([]byte(`{"error":"Error occurred"}`))
}
```
# Бизнес-логика на своём месте
Часто кандидаты помещают всю логику или на уровень хэндлера (контроллера), или на уровень работы с базой данных.
Это лишает приложение гибкости. Лучше разделять его на разные слои.
- Если транспортный слой (хэндлеры) содержит основную логику, то её сложно переиспользовать,если в дальнейшем мы захотим поменять или добавить новый протокол (например, grpc+rest api).
- Если логика вынесена на уровень инфраструктуры (баз данных), то это затруднит работу с разными хранилищами.
Такую логику обычно выносят на уровень сервисов.
Следует ограничивать взаимодействие между слоями, например, использование базы данных в хендлере.
Для управления направлением зависимостей между слоями лучше использовать интерфейсы.

Хороший пример:
```go
// internal/usecase/tender/deps.go
type TenderRepository interface {
    GetTenderById(ctx context.Context, tenderID uuid.UUID) (model.Tender, error)
}

// internal/usecase/tender.go
type TenderUsecase struct {
    tenderRepository TenderRepository
}

// internal/repository/tender/repository.go
func (r *Repository) GetTenderById(ctx context.Context, id uuid.UUID) (tender.Tender, error) {
    // implementation of TenderRepository
}
```

Интерфейс `TenderRepository` можно использовать для генерации моков для тестирования usecase-а.

На тему разделения логики на слои можно почитать про Чистую или Гексагональную Архитектуры.

Также рекомендуем почитать [совет для прошлой волны](https://github.com/avito-tech/tech-internship/blob/main/Tech%20Internships/Backend/Backend-trainee-assignment-spring-2024/Solution%20and%20advice/%D0%91%D0%B8%D0%B7%D0%BD%D0%B5%D1%81-%D0%BB%D0%BE%D0%B3%D0%B8%D0%BA%D0%B0%20%D0%B2%20handler.md).

# Код покрыт тестами

Самый распространённый недочёт в этой волне — отсутствие тестов.

Задание было очень объёмным,но всё-таки стоитнаписать хотя бы несколько тестов для того, чтобы показать свои навыки и понимание темы.
В идеале покрыть тестами несколько типичных методов: хэндлер, сервис, метод для работы с базой данных.

Лучше использовать табличные тесты, это обычно позволяет сократить количество кода в тестовых файлах.

# Логирование ошибок

В реальных системах, использующих микросервисы, применяются 4 вида сигналов для наблюдения за состоянием системы:логи, метрики, алерты и распределённый трейсинг.

Проще всего добавить в свой сервислоги.
Сделать это можно, например, так:
Инициализируем логгер в файле `main.go` и передаём его в конструкторы, например, сервисов.
```go
lgr := slog.New(slog.NewJSONHandler(os.Stderr, nil))

serviceBid := service.NewBidService(lgr)
```

При обработке запросов внутри сервисов мы сможем логировать важную информацию.

```go
func NewBidService(lgr *slog.Logger) *BidService {
	return &BidService{
		lgr: lgr,
	}
}

func (s *BidService) CreateBid(ctx context.Context, data *Request) (Response, error) {
	if bid.Name == "" {
		s.lgr.With(
			slog.String("username", data.UserName),
		).Error("creating a bid: username is empty")

		return Response{}, ErrUsernameFieldEmpty
	}
}
```

Конечно, в сервисах лучше использовать интерфейсы на сущности, это упрощает тестирование через мок-объекты.
Но это уже немного другая тема.

# Пользователь не должен видеть полные ошибки

Часто пользователю отправляются ошибки напрямую из, например, базы данных.  Ему такая информация не нужна.
Более того, таким образом мы облегчаем злоумышленнику задачу взлома нашей базы данных - ему будет легче сразу видеть результат своих действий.
Особенно это опасно, если мы не озаботились валидацией пользовательских данных и правильной генерацией SQL-запросов.

```go
func (s *BidService) CreateBid(ctx context.Context, data *Request) (Response, error) {
	err := s.db.CreateBid(ctx, data)
	if err != nil {
		s.lgr.With(
			slog.Any("username", bid.UserName),
		).Error("creating a bid: " + err.Error())

		return Response{}, InternalError
	}
}
```
Выше показан упрощённый пример. Обычно ошибки подменяются на пользовательские на транспортном уровне.

# Грамотное использование транзакций

При добавлении или изменении данных в базе важно использовать транзакции. Часто изменения касаются нескольких таблиц в рамках одной операции со стороны пользователя. Чтобы сохранить консистентность данных, все изменения лучше делать в рамках одной транзакции.

Пример того, как это можно реализовать:
```go
func (s *Storage) SubmitBidDecision(ctx context.Context, bidID, tenderID uuid.UUID) (err error) {
	tx, err := s.conn.Begin(ctx)
	if err != nil {
		return fmt.Errorf("starting transaction: %w", err)
	}

	defer func() {
		var e error
		if err == nil {
			e = tx.Commit(ctx)
		} else {
			e = tx.Rollback(ctx)
		}

		if err == nil && e != nil {
			err = fmt.Errorf("finishing transaction: %w", e)
		}
	}()

	queryBid := `
UPDATE bid
SET
	status = $1
WHERE id = $2 ;`

	if _, err = tx.Exec(ctx, queryBid, model.BidStatusApproved, bidID); err != nil {
		return fmt.Errorf("updating bids: %w", err)
	}

	queryTender := `
UPDATE tender
SET
	status = $1
WHERE id = $2;`

	if _, err = tx.Exec(ctx, queryTender, model.TenderStatusClosed, tenderID); err != nil {
		return fmt.Errorf("updating tenders: %w", err)
	}

	return nil
}
```

*вопросу правильного построения запросов к базе данных посвящён отдельный совет.

При этом не стоит использовать транзакции всегда.
Об этом можно прочитать в [совете для предыдущей волны](https://github.com/avito-tech/tech-internship/blob/main/Tech%20Internships/Backend/Backend-trainee-assignment-spring-2024/Solution%20and%20advice/%D0%9F%D0%BE%D0%B2%D1%81%D0%B5%D0%BC%D0%B5%D1%81%D1%82%D0%BD%D0%BE%D0%B5%20%D0%B8%D1%81%D0%BF%D0%BE%D0%BB%D1%8C%D0%B7%D0%BE%D0%B2%D0%B0%D0%BD%D0%B8%D0%B5%20%D1%82%D1%80%D0%B0%D0%BD%D0%B7%D0%B0%D0%BA%D1%86%D0%B8%D0%B9.md)

## Альтернативные варианты работы с транзакцией

Кроме ручной работы с транзакциями в слое базы данных можно использовать менеджер транзакций,у нас есть отличная [статья на хабре про него](https://habr.com/ru/companies/avito/articles/727168/).

## Защита от ошибок при конкурентном использовании (продвинутый кейс)

Пример выше не гарантирует, что конкурентная транзакция уже не изменила статус тендера.
Чтобы обеспечить корректную работу сервиса в этой ситуации, необходимо дополнительно проработать логику:

- использовать явные блокировки https://postgrespro.ru/docs/postgrespro/17/explicit-locking;
- полагаться на уровни изоляции в транзакции, например, создать транзакцию с уровнем Repeatable read/Serializable,внутри транзакции запросить статус тендера и рассчитывать на то,
что база данных автоматически отклонит транзакцию в случае, если параллельная транзакция изменит статус;
- в рамках одного запроса сделать проверку статуса и его обновление, с этим может помочь CTE.

# Построение запросов к базе данных

Для безопасной вставки пользовательских данных в базу нужно их экранировать.  Обычно для простоты экранируют все данные, которые добавляются/изменяются в базе.

Также для переиспользования одного query в разных SQL-запросах (например, с разными условиями `where`, для использования в подзапросах и т.п.),
часто прибегают к помощи SQL generators или SQL Query Builders.

В рамках тестового задания использование генераторов может быть чрезмерным, поэтому проще воспользоваться билдером запросов, например, [Squirrel](https://github.com/Masterminds/squirrel).

Пример использования:
```go
func (s *Storage) SubmitBidDecision(ctx context.Context, bidID, tenderID uuid.UUID) (err error) {
	// ...

	// достаточно инициализировать builder один раз и присвоить структуре.
	builder := squirrel.StatementBuilder.PlaceholderFormat(squirrel.Dollar)

	query, args, err := builder.Update("bid").
		Set("status", model.BidStatusApproved).
		Where(squirrel.Eq{"id": bidID}).
		ToSql()
	if err != nil {
		return fmt.Errorf("building query: %w", err)
	}

	_, err = s.conn.Exec(ctx, query, args...)
	if err != nil {
		return fmt.Errorf("executing query: %w", err)
	}

	// ...

	return nil
}
```

Таким образом мы гарантируем, что данные для вставки будут экранированы. Более того, в Squirrel есть приятные бонусы, например, кэширование prepared statements.

Эта тема также обсуждалась в [советах к прошлой волне](https://github.com/avito-tech/tech-internship/blob/main/Tech%20Internships/Backend/Backend-trainee-assignment-spring-2024/Solution%20and%20advice/%D0%9F%D0%BE%D1%81%D1%82%D1%80%D0%BE%D0%B5%D0%BD%D0%B8%D0%B5%20%D0%B4%D0%B8%D0%BD%D0%B0%D0%BC%D0%B8%D1%87%D0%B5%D1%81%D0%BA%D0%B8%D1%85%20%D0%B7%D0%B0%D0%BF%D1%80%D0%BE%D1%81%D0%BE%D0%B2%20%D0%BA%20%D0%91%D0%94.md).


# Стажировки для Backend-разработчиков в Авито: на что мы смотрим при проверке работ

Наши эксперты проанализировали тестовые задания кандидатов прошедшего отбора и рассказали о том, какие ошибки встречались чаще всего.
Все совпадения случайны!

---

## Валидация бизнес-правил

Во многих проектах бизнес-правила — например, допустимые города или типы товаров — проверялись только на уровне базы данных.

**Пример:**

```sql
city VARCHAR(100) NOT NULL
   CHECK (city IN ('Москва', 'Санкт-Петербург', 'Казань')),
type VARCHAR(50) NOT NULL
   CHECK (type IN ('electronics', 'clothing', 'shoes')),
status VARCHAR(20) NOT NULL
   CHECK (status IN ('in_progress', 'closed'))
   DEFAULT 'in_progress'
```
На первый взгляд кажется, что решение простое и надёжное: база не позволит записать некорректные данные. Однако на практике это создаёт больше проблем, чем пользы.

---

### Почему так не стоит делать

1. **Нарушается принцип разделения ответственности**
   Бизнес-правила — это часть прикладной логики, а не уровня хранения данных. Когда их вшивают в схему, валидация расползается между слоями.

2. **Становится неудобно сопровождать базу данных**
   Чтобы изменить бизнес-правила, приходится создавать миграции, перекатывать схему, пересоздавать constraint. Особенно сложно, когда бизнес-правила часто меняются — к примеру, добавляется много новых городов или типов товаров.

3. **Некорректно обрабатываются ошибки**

**Какая ошибка должна быть:**
```json
{"error": "город 'Томск' недоступен для открытия ПВЗ"}
```

**Какой она будет, если вшить бизнес-правила в базу данных:**
```
pq: new row for relation "pvz" violates check constraint "allowed_city"
```

Обработку ошибок можно исправить дублированием логики в приложении — но в таком случае теряется единый источник истины и повышается риск расхождений.

4. **Такой код сложнее тестировать**
   Если валидация проведена только на уровне базы данных, её невозможно проверить в отрыве от инфраструктуры.

5. **Базу данных становится сложно переносить**
   СУБД по-разному реализуют ограничения, а в некоторых их и вовсе может не быть.

---

### Как тогда делать

Рекомендуем проводить валидацию на уровне приложения. База данных должна обеспечивать только целостность — например, `NOT NULL` и внешние ключи.

В редких случаях в базе может быть дополнительная защита — но только если вы уверены, что список будет меняться редко. Даже тогда это не должно быть единственным местом проверки.

---

## Хранение данных

В некоторых проектах поля `city`, `type` и `status` хранились как `VARCHAR` или `TEXT`. На первый взгляд кажется, что это просто и удобно, но у такого подхода есть серьёзные недостатки.

---

### Почему так не стоит делать

1. **Становится сложно вносить изменения**
   Если понадобится переименовать значение — например, `"clothing"` в `"clothing/t-shirt"` — придётся обновлять все записи в таблице. Это долго, ресурсоёмко и повышает риск рассинхронизации.

2. **Снижается эффективность кода**
   Строки занимают больше места, чем числовые идентификаторы. Операции сравнения строк выполняются медленнее, чем сравнение чисел, особенно на больших объёмах данных.

3. **Появляются трудности в индексации и агрегации**
   Индексы по строковым полям больше по размеру и работают медленнее. Это снижает производительность фильтрации, сортировки и агрегирующих запросов.

---

## Почему не стоит полагаться на ENUM

Другой распространённый вариант — использовать `ENUM` вместо строк. У такого подхода есть плюсы, но и существенные минусы.

1. **Чтобы изменить или удалить значение, придётся перестраивать всю таблицу.**
   Если таблица большая, это приводит к блокировкам и простоям.

2. **Ограничивается гибкость.**
   При добавлении новых значений приходится постоянно обновлять миграции.

---

### Как тогда делать

Рекомендуем провести нормализацию данных. Самое устойчивое решение — вынести справочники (`city`, `type`, `status`) в отдельные таблицы:

- Таблица **cities** (`id`, `name`)
- Таблица **product_types** (`id`, `name`)
- Таблица **statuses** (`id`, `name`)

А в основной таблице хранить только целочисленные ключи: `city_id`, `type_id`, `status_id`.

**Плюсы подхода:**
- Быстрое хранение и сравнение.
- Возможность централизованно менять значения.
- Удобство индексации и агрегации.
- Гибкость структуры.

---

## Работа с индексами

Во многих решениях кандидаты не добавляли индексы к таблицам. На тестовых данных это может быть незаметно, но в реальной системе быстро приводит к проблемам.

---

### Почему так не стоит делать

1. **Снижается производительность запросов.**
   При фильтрации или `JOIN` без индексов база сканирует всю таблицу.

2. **Усложняется масштабирование.**
   При росте объёма данных запросы начинают выполняться значительно дольше.

---

### Как тогда делать

В таблицах важно добавлять индексы для:
- Полей, используемых в фильтрах (`WHERE city_id = ? AND date BETWEEN …`),
- Внешних ключей и связей между таблицами,
- Полей сортировки и пагинации (`ORDER BY created_at, id`).

Для сложных фильтров — используйте составные индексы, например `(pvz_id, date)`.

⚠️ **Важно:** избыточные индексы замедляют записи (`INSERT`, `UPDATE`, `DELETE`) и занимают место. Добавляйте их только после анализа `EXPLAIN ANALYZE`.

---

## Тестирование кода

Во многих работах код не был протестирован. Часто кандидаты покрывают тестами инфраструктурные части, но не бизнес-логику.

---

### Как делать не надо

```go
func TestGetUserRepository(t *testing.T) {
   repo := NewUserRepo(mockDB)
   _, err := repo.GetByID(42)
   require.NoError(t, err)
}
```

---

### Почему так не стоит делать

1. **Создаётся ложное чувство защищённости.**
   Такие тесты не ловят ошибки в логике.

2. **Смещается фокус внимания.**
   Проверяются детали реализации, а не сценарии.

3. **Повышаются трудозатраты.**
   Инфраструктурные тесты часто ломаются при рефакторинге.

---

### Как тогда делать

Сосредоточьтесь на тестировании бизнес-логики:
- Переходы состояний (например, статусы заказов).
- Расчёты скидок и комиссий.
- Обработку ошибок и граничных условий.

---

## «Толщина» интерфейса

Иногда встречаются интерфейсы, объединяющие слишком много сущностей.

---

### Как делать не надо

```go
type Repository interface {
    CreateUser(...)
    GetUserByEmail(...)
    CreatePVZ(...)
    GetReceptionByID(...)
    CreateProduct(...)
}
```

---

### Как тогда делать

Разделяйте интерфейсы по доменам — `UserRepository`, `PVZRepository`, `ProductRepository`.
Это повышает читаемость, тестопригодность и гибкость архитектуры.

---

## Собранность бизнес-логики

Бизнес-логика должна быть сосредоточена в одном сервисном слое. Когда проверки и бизнес-правила размазаны по обработчикам, репозиториям и вспомогательным функциям — код становится нечитабельным.

---

### Как тогда делать

- Бизнес-правила — в сервисах.
- Репозитории — только за доступ к данным.
- Handlers — только за приём и отдачу запросов.

---

## Лаконичность в транзакциях

Не стоит оборачивать каждую операцию в транзакцию.

---

### Как делать не надо

```go
func (r *PostgresRepo) GetLastOrder(ctx context.Context, warehouseID int) (*Order, error) {
   var order Order
   err := r.withTx(ctx, func(tx *sqlx.Tx) error {
       return tx.QueryRowContext(
           ctx,
           `SELECT id, status FROM orders WHERE warehouse_id = $1 ORDER BY created_at DESC LIMIT 1`,
           warehouseID,
       ).Scan(&order.ID, &order.Status)
   })
   if err != nil {
       return nil, fmt.Errorf("failed to get last order: %w", err)
   }
   return &order, nil
}
```

---

### Как тогда делать

Используйте транзакции только там, где нужно сохранить атомарность нескольких изменений. Решение о применении транзакции должно приниматься на уровне бизнес-логики.

---

## Работа с конфигурацией

Нельзя хранить чувствительные данные в коде.

---

### Как делать не надо

```go
sql.Open("postgres", "postgres://user:password@localhost:5432/master")
```

---

### Как тогда делать

Используйте переменные окружения:

```go
sql.Open("postgres", os.Getenv("DB_CONN"))
```

**Примеры:**
- `export DB_CONN="postgres://user:password@localhost:5432/master"`
- `.env` файл
- Docker/Kubernetes параметры
- Vault или другое хранилище секретов

---

## Настройка линтеров

Несоблюдение форматирования и правил стиля снижает читаемость и качество кода.

---

### Как делать не надо

```go
func add(a int, b int) int {
   return a+b
}
```

**При запуске линтера:**
```
gofmt: File is not formatted with gofmt
```

---

### Как тогда делать

Настройте линтеры и автоформатирование (например, `pre-commit hook`).
Регулярно обновляйте конфигурацию линтеров.

---

## Логирование в приложении

Ошибки нужно логировать, а не игнорировать.

---

### Как делать не надо

```go
func handleRequest(w http.ResponseWriter, r *http.Request) {
   if _, err := db.Query("INSERT INTO user(name) VALUES('test')"); err != nil {
       w.WriteHeader(http.StatusBadRequest)
   } else {
       w.WriteHeader(http.StatusOK)
   }
}
```

---

### Как тогда делать

Используйте логирование (например, Zap или Slog).
Не логируйте чувствительные данные (пароли, токены).

---

# Стажировки для Backend-разработчиков в Авито: на что мы смотрим при проверке работ — первая часть

Наши эксперты отсмотрели много тестовых заданий кандидатов — и теперь делятся распространёнными ошибками, чтобы вы могли учесть их в будущем.

## 1. Code style и структура кода

### 1.1. Сортировка импорта
В некоторых проектах отсутствовал единый автоформат, были перемешаны импорты, а отступы и переносы строк — не согласованы.

**Почему так не стоит делать**
В таком случае падает читаемость кода и скорость код-ревью. Растёт вероятность случайных конфликтов и мелких ошибок при правках.

**Как правильно**
Стоит включить автоформат и линтер.

---

### 1.2. Разделение обработчиков (handlers)
В работах многих кандидатов обработчики были собраны в одном файле. В `handlers.go` лежали все эндпоинты — `/api/auth`, `/api/info` — без логического разделения по доменам.

**Почему так не стоит делать**
В такой ситуации файл разрастается, усложняется навигация, растёт риск конфликтов и утечек ответственности между обработчиками.

**Как правильно**
Стоит разложить эндпоинты по ресурсам или доменам.

**Хороший пример:**
```bash
/internal/http/handlers/
  auth.go       // /api/auth
  coins.go      // /api/sendCoin
  ...
```

---

### 1.3. Моки и код в проде
Часто моки лежат там же, где основной код.

**Почему так не стоит делать**
В таком случае в навигации появляется шум, растёт риск того, что в проде случайно используется мок, а зависимости пересекутся.

**Как правильно**
Хранить моки стоит в `mocks/`, а генерировать — через `mockery`. Больше деталей ищите в документации.

---

### 1.4. Названия структур внутри функций
Иногда в функциях создаются «сырые» `struct{...}` вместо именованных типов.

**Почему так не стоит делать**
Не получается переиспользовать типы, трудно проводить валидацию и тестирование.

**Как правильно**
Стоит ввести именованные DTO или domain-модели.

**Плохой пример**
```go
req := struct{ Name string }{Name: "John"}
```

**Хороший пример**
```go
type User struct {
  Name string
}
```

---

## 2. Архитектура и разделение слоёв

### 2.1. Бизнес-логика и слои
В некоторых проектах HTTP-слой содержал бизнес-логику и выполнял операции с базами данных.

**Почему так не стоит делать**
В такой ситуации код трудно тестировать, повторно использовать и менять логику без изменений в HTTP-handlers.

**Как правильно**
Стоит оставлять валидацию входных данных на уровне `handlers`, а бизнес-логику реализовывать в `usecase` — то есть придерживаться чистой архитектуры.

**Хороший пример:**
```go
// Handler: только парсинг и маппинг.
func (h *Handler) SendCoin(w http.ResponseWriter, r *http.Request) {
    var in SendCoinInput
    ctx := r.Context()

    if err := json.NewDecoder(r.Body).Decode(&in); err != nil {
        http.Error(w, "bad request", 400)
        return
    }

    if err := h.usecase.SendCoin(ctx, in.From, in.To, in.Amount); err != nil {
        http.Error(w, err.Error(), 500)
        return
    }
}
```

---

### 2.2. Зависимость билдера
Часто бывает так, что билдер импортирует реализацию, а не интерфейс.

**Почему так не стоит делать**
Появляется жёсткая связность. В таком случае не получится мокать зависимость в тестах и менять реализацию.

**Как правильно**
Стоит объявлять интерфейсы на стороне потребителя и создавать зависимость от интерфейса.

**Хороший пример:**
```bash
/internal/repo/merch/
  merch.go                // Реализация репозитория merch.
/internal/service/merch/
  merch.go                // Реализация сервиса merch.
```

```go
// /internal/service/merch/merch.go
package merch

type MerchRepo interface {
    Get(ctx context.Context, name string) error
}

type MerchService struct {
    Repo MerchRepo
}
```

---

### 2.3. Миграции
Иногда кандидаты пишут миграции баз данных полностью в `init.sql`.

**Почему так не стоит делать**
Становится сложно откатывать или перекатывать миграции частями, теряется история изменений.

**Как правильно**
Стоит создавать отдельные миграции, а для управления ими использовать специальный инструмент — например, golang-migrate.

**Хороший пример:**
```bash
/migrations/
  0001_init.sql
  0002_add_merch.sql
```

---

## 3. Тесты

### 3.1. Юнит-тесты и e2e
Проверяйте, что код покрыт тестами и они не падают, не появляются flaky тесты.

**Как правильно**
Стоит добиваться зелёных тестов и исправлять причины flaky тестов. Например, они могут появляться при проверке равенства map — порядок ключей всегда разный.

---

### 3.2. Отдельное тестовое окружение
Следите за тем, чтобы тесты не использовали ту же базу данных, что и приложение. Иначе данные сломаются, и тесты станут нестабильными.

**Как правильно**
Стоит поднимать отдельную тестовую базу данных. А e2e-тесты лучше выделить в отдельный `docker-compose.e2e.yaml` со своими базами данных, переменными и сетью.

**Хороший пример:**
```yaml
# docker-compose.e2e.yaml
services:
  db_e2e:
    image: postgres:15
    environment:
      POSTGRES_DB: database
      POSTGRES_PASSWORD: password
  api_e2e:
    build: .
    env_file: .env.e2e
    depends_on: [db_e2e]
  tests:
    build: ./e2e_tests
    depends_on: [api_e2e]
```

---

## 4. DevOps и окружение

### 4.1. Работа `docker compose up`
В некоторых проектах сервис не поднимается без ручных правок, в CI не запускается окружение.

**Как правильно**
Стоит регулярно проверять чистый старт, добавлять healthchecks и зависимости, прописывать entrypoint для миграций.

---

### 4.2. Совпадение версий Go в `go.mod` и Dockerfile
Бывает, в `go.mod` указана одна версия Go, а образ сборки в Dockerfile — другой. В таком случае сборка падает.

**Как правильно**
Стоит синхронизировать версии и использовать multi-stage build.

**Хороший пример:**
```dockerfile
FROM golang:1.22

WORKDIR ${GOPATH}/avito-shop/
COPY . ${GOPATH}/avito-shop/

RUN go build -o /build ./internal/cmd     && go clean -cache -modcache

EXPOSE 8080
CMD ["/build"]
```

---

### 4.3. Заголовки для JWT
Иногда кандидаты кладут токен в произвольный заголовок вместо `Authorization: Bearer <token>`. Это приводит к несовместимости с библиотеками и путанице в клиентах и тестах.

**Как правильно**
Стоит придерживаться стандартных заголовков.

**Плохой пример:**
```http
GET /api/info HTTP/1.1
Host: localhost:8080
X-Auth: eyJhbGciOiJIUzI1NiIsInR5cCI6...
```

**Хороший пример:**
```http
GET /api/info HTTP/1.1
Host: localhost:8080
Authorization: Bearer eyJhbGciOiJIUzI1NiIsInR5cCI6...
```

```go
// Чтение токена.
auth := r.Header.Get("Authorization")

const prefix = "Bearer "

if !strings.HasPrefix(auth, prefix) {
  http.Error(w, "unauthorized", http.StatusUnauthorized)
  return
}

token := strings.TrimPrefix(auth, prefix)
// Далее валидация token...
```

---

## 5. Безопасность

### 5.1. Коммиты `.env` в репозиторий
Ошибка, которая встречается очень часто: секреты — к примеру, JWT-ключ или пароли — лежат в репозитории. Это может приводить к серьёзным утечкам данных.

**Как правильно**
Стоит добавлять `.env` в `.gitignore`, хранить только `.env.example`. Также важно использовать переменные окружения или секрет-менеджер.

**Хороший пример:**
```go
type Config struct {
    JWTKey string `env:"JWT_KEY,required"`
}
```

---

### 5.2. Хеширование паролей
Ещё одна частая ошибка, когда пароли пользователей хранятся в базе данных в открытом виде. Это может приводить к компрометации и репутационным рискам.

**Как правильно**
Стоит хранить bcrypt-хеши.

---

## 6. Баги в бизнес-логике

### 6.1. Накрутка монет
В некоторых проектах пользователь может отправить монеты сам себе: такие лазейки обычно приводят к накруткам баланса и фроду.

**Как правильно**
Стоит добавлять валидацию `from user != to user`.

**Хороший пример:**
```go
if fromUserID == toUserID { return ErrSelfTransfer }
```

---

### 6.2. Неатомарные операции
В некоторых проектах баланс может меняться без транзакции.

**Как правильно**
Стоит оборачивать бизнес-операции в транзакции базы данных. Для этого нужно использовать transaction-manager.

**Хороший пример:**
```go
err := trManager.Do(ctx, func(ctx context.Context) error {
    balance, err := GetBalance(ctx, fromUser)
    if err != nil {
        return err
    }

    if balance < amount {
        return ErrInsufficientFunds
    }

    if err := AddBalance(ctx, fromUser, -amount); err != nil {
        return err
    }

    if err := AddBalance(ctx, toUser, amount); err != nil {
        return err
    }

    return nil
})
```

---

### 6.3. Сравнивание ошибок
Бывает, ошибки сопоставляются через `==` или `strings.Contains()`. В таком случае растёт риск пропустить специфичную ошибку — а проверить обёрнутую ошибку и вовсе становится невозможно.

**Как правильно**
Стоит использовать `errors.Is()`.

**Хороший пример:**
```go
if errors.Is(err, ErrInsufficientFunds) { /* ... */ }
```

---

## 7. Технический долг

### 7.1. `TODO` без привязки к задаче
Оставлять комментарии-заглушки без номера тикета и срока — это моветон. Так статус кода становится неясным, копятся долги.

**Как правильно**
Стоит переносить todo в issue-трекер, а в коде ссылаться на задачу.

**Хороший пример:**
```go
// TODO (TASK-123): Заменить поход в БД на кэш к 01.01.26.
```

https://github.com/avito-tech/tech-internship/tree/main/Tech%20Internships/Backend/Backend-trainee-assignment-spring-2024/Solution%20and%20advice
